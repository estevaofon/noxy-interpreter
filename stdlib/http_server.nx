// stdlib/http_server.nx - Servidor HTTP Event-Driven

use net select *
use io
use http_parser select *

// ============================================
// Estruturas
// ============================================

struct HttpServer
    host: string,             // "0.0.0.0"
    port: int,                // 8080
    server_socket: Socket,    // Socket do listener
    running: bool,            // Flag de controle
    client_sockets: Socket[64], // Array de clientes conectados
    handler: int              // Placeholder
end

struct RequestEvent
    type: string,             // "REQUEST", "NONE", "ERROR"
    client_index: int,        // Índice do cliente no array
    request: HttpRequest
end

// ============================================
// Factory & Lifecycle
// ============================================

func new_server(host: string, port: int) -> HttpServer
    // Cria servidor com socket inválido inicial
    // Cria servidor com socket inválido inicial
    // Socket() cria um inválido por padrão (fd=-1)
    let s: Socket = Socket(-1, "", 0, false) 
    let sockets: Socket[64]
    
    return HttpServer(host, port, s, false, sockets, 0)
end

func start(server: ref HttpServer) -> bool
    let s: Socket = listen(server.host, server.port)
    if !s.open then
        return false
    end
    
    server.server_socket = s
    setblocking(s, false) // Non-blocking accept
    server.running = true
    
    // Inicializa slots de clientes ? Já são Socket() inválidos
    return true
end

func stop(server: ref HttpServer) -> void
    server.running = false
    net_close(server.server_socket)
    
    let i: int = 0
    while i < 64 do
        if server.client_sockets[i].open then
            net_close(server.client_sockets[i])
        end
        i = i + 1
    end
end

// ============================================
// Event Loop
// ============================================

func server_poll(server: ref HttpServer) -> RequestEvent
    // Evento padrão (None)
    let empty_headers: string[64]
    let no_event: RequestEvent = RequestEvent("NONE", -1, HttpRequest("GET", "/", "", "HTTP/1.1", empty_headers, 0, b""))
    
    // Arrays para select
    let inputs: Socket[64]
    let outputs: Socket[64]
    let errors: Socket[64]
    
    // 1. Preparar lista de inputs
    inputs[0] = server.server_socket
    let input_count: int = 1
    
    let i: int = 0
    while i < 64 do
        if server.client_sockets[i].open then
            if input_count < 64 then
                inputs[input_count] = server.client_sockets[i]
                input_count = input_count + 1
            end
        end
        i = i + 1
    end
    
    // 2. Select (timeout 50ms)
    let res: SelectResult = select(inputs, outputs, errors, 50)
    
    if res.read_count > 0 then
        let j: int = 0
        while j < res.read_count do
            let active_sock: Socket = res.read[j]
            
            // Verifica se é o listener
            let is_listener: bool = false
            if active_sock == server.server_socket then
                is_listener = true
            end
            
            if is_listener then
                // Accept new connection
                let client: Socket = accept(server.server_socket)
                if client.open then
                    setblocking(client, false)
                    
                    // Add to slots
                    let added: bool = false
                    let k: int = 0
                    while k < 64 do
                        if !server.client_sockets[k].open then
                            server.client_sockets[k] = client
                            added = true
                            break
                        end
                        k = k + 1
                    end
                    
                    if !added then
                        print("Server full")
                        net_close(client)
                    end
                end
                // Continue loop processing other sockets? 
                // For simplicity, we process one event per poll or just minimal internal work
            else
                // Read from client
                let recv_res: NetResult = recv(active_sock, 16384)
                
                // Identify client index
                let client_idx: int = -1
                let k: int = 0
                while k < 64 do
                    if server.client_sockets[k] == active_sock then
                        client_idx = k
                        break
                    end
                    k = k + 1
                end
                
                if !recv_res.ok | (recv_res.count == 0) then
                    // Closed
                    net_close(active_sock)
                    if client_idx != -1 then
                        server.client_sockets[client_idx] = Socket(-1, "", 0, false)
                    end
                else
                    // Data received -> Parse Request
                    if client_idx != -1 then
                        let req: HttpRequest = parse_request(recv_res.data, recv_res.count)
                        return RequestEvent("REQUEST", client_idx, req)
                    end
                end
            end
            
            j = j + 1
        end
    end
    
    return no_event
end

func server_send(server: ref HttpServer, client_index: int, resp: HttpResponse) -> void
    if (client_index >= 0) & (client_index < 64) then
        let sock: Socket = server.client_sockets[client_index]
        if sock.open then
            let resp_bytes: bytes = build_response(resp.status_code, resp.status_text, resp.headers, resp.header_count, resp.body)
            send(sock, resp_bytes)
            
            // Close after send (HTTP 1.0 style for MVP)
            net_close(sock)
            server.client_sockets[client_index] = Socket(-1, "", 0, false)
        end
    end
end

// ============================================
// Response Helpers
// ============================================

func response_ok(body: bytes, content_type: string) -> HttpResponse
    let headers: string[64]
    headers[0] = "Content-Type: " + content_type
    headers[1] = "Content-Length: " + to_str(length(body))
    
    return HttpResponse("HTTP/1.1", 200, "OK", headers, 2, body)
end

func response_error(status_code: int, message: string) -> HttpResponse
    let body: bytes = to_bytes(message)
    let headers: string[64]
    headers[0] = "Content-Type: text/plain"
    headers[1] = "Content-Length: " + to_str(length(body))
    
    return HttpResponse("HTTP/1.1", status_code, get_status_text(status_code), headers, 2, body)
end

func response_json(data: string) -> HttpResponse
    return response_ok(to_bytes(data), "application/json")
end

func response_html(html: string) -> HttpResponse
    return response_ok(to_bytes(html), "text/html")
end

// ============================================
// Static Files
// ============================================

func serve_file(filepath: string) -> HttpResponse
    // Verifica existência
    // Assumindo io.exists disponível (se não for, open falha)
    // Vamos tentar abrir direto
    
    let f: File = io.open(filepath, "r")
    // Como verificar se abriu? File tem 'open' ou similar?
    // io.nx geralmente retorna File struct. Se falha, pode dar erro ou retornar file inválido.
    // Vamos assumir que temos como checar ou usar try-catch se Noxy tivesse... 
    // Spec do IO diz que open retorna File. File tem handle?
    // Vamos assumir que open lança erro ou retorna algo checável.
    // Baseado na spec anterior do IO: File tem descriptor?
    
    // Simplificação: vamos ler. Se der erro de leitura, return 500/404.
    // io.read retorna IOResult?
    // io.nx original: 
    // func read(f: File) -> IOResult
    
    let res: IOResult = io.read(f)
    io.close(f)
    
    if !res.ok then
        return response_error(404, "File not found or unreadable")
    end
    
    let content: string = res.data
    // IOResult.data é string. Precisamos de bytes para o body.
    // Arquivos binários (imagens) lidos como string podem corromper se Noxy strings forem utf-8 strict.
    // O io.nx usa 'read_text' ou 'read_binary'?
    // stdlib/io.nx mostrava 'io_read' retornando string.
    // Se quisermos servir imagens, precisaria ser bytes.
    // MVP: serve como string convertida para bytes. Pode quebrar imagens.
    
    let body: bytes = to_bytes(content)
    
    // Detect Mime Type (simplificado por extensão)
    let mime: string = "application/octet-stream"
    if contains(filepath, ".html") then mime = "text/html" end
    if contains(filepath, ".css") then mime = "text/css" end
    if contains(filepath, ".js") then mime = "application/javascript" end
    if contains(filepath, ".json") then mime = "application/json" end
    if contains(filepath, ".png") then mime = "image/png" end
    if contains(filepath, ".jpg") then mime = "image/jpeg" end
    
    let headers: string[64]
    headers[0] = "Content-Type: " + mime
    headers[1] = "Content-Length: " + to_str(length(body))
    
    return HttpResponse("HTTP/1.1", 200, "OK", headers, 2, body)
end

// Helper contains (necessário para ext check)
func contains(haystack: string, needle: string) -> bool
    let parts: string[2] = split_once(haystack, needle)
    if strlen(parts[1]) > 0 | (strlen(parts[0]) < strlen(haystack)) then
        // Se split funcionou (encontrou), o tamanho muda ou parts[1] tem algo
        // split_once retorna [s, ""] se falhar
        if parts[1] == "" & parts[0] == haystack then
            return false
        end
        return true
    end
    return false
end
