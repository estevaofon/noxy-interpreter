// stdlib/http_parser.nx - Parser HTTP/1.1

// ============================================
// Estruturas de Dados
// ============================================

struct HttpRequest
    method: string,           // "GET", "POST", etc
    path: string,             // "/api/users"
    query: string,            // "id=123&name=test" (sem o '?')
    version: string,          // "HTTP/1.1"
    headers: string[64],      // Array de headers "Name: Value"
    header_count: int,        // Número de headers válidos
    body: bytes               // Corpo da requisição
end

struct HttpResponse
    version: string,          // "HTTP/1.1"
    status_code: int,         // 200, 404, 500, etc
    status_text: string,      // "OK", "Not Found", etc
    headers: string[64],      // Array de headers
    header_count: int,
    body: bytes
end

struct HttpUrl
    scheme: string,           // "http" ou "https"
    host: string,             // "api.example.com"
    port: int,                // 80, 443, 8080, etc
    path: string,             // "/api/users"
    query: string,            // "id=123" (sem o '?')
    fragment: string,         // "section1" (sem o '#')
    valid: bool               // true se parse OK
end

// ============================================
// Constantes e Helpers
// ============================================

// Status codes comuns
let HTTP_200_OK: int = 200
let HTTP_201_CREATED: int = 201
let HTTP_204_NO_CONTENT: int = 204
let HTTP_400_BAD_REQUEST: int = 400
let HTTP_404_NOT_FOUND: int = 404
let HTTP_500_INTERNAL_ERROR: int = 500

// Content-Type comuns
let CONTENT_TYPE_JSON: string = "application/json"
let CONTENT_TYPE_HTML: string = "text/html"
let CONTENT_TYPE_TEXT: string = "text/plain"
let CONTENT_TYPE_CSS: string = "text/css"
let CONTENT_TYPE_JS: string = "application/javascript"
let CONTENT_TYPE_PNG: string = "image/png"
let CONTENT_TYPE_JPEG: string = "image/jpeg"

func get_status_text(code: int) -> string
    if code == 200 then return "OK" end
    if code == 201 then return "Created" end
    if code == 204 then return "No Content" end
    if code == 400 then return "Bad Request" end
    if code == 401 then return "Unauthorized" end
    if code == 403 then return "Forbidden" end
    if code == 404 then return "Not Found" end
    if code == 500 then return "Internal Server Error" end
    if code == 502 then return "Bad Gateway" end
    if code == 503 then return "Service Unavailable" end
    return "Unknown"
end

// Encontra próxima ocorrência de \r\n (13, 10 bytes)
// Retorna -1 se não encontrar
func find_crlf(data: bytes, start: int, len: int) -> int
    let i: int = start
    while i < len - 1 do
        // Checando manualmente os bytes para CR (13) e LF (10)
        // Como o tipo é bytes, acesso por índice retorna int (byte value)
        if data[i] == 13 then
            if data[i+1] == 10 then
                return i
            end
        end
        i = i + 1
    end
    return -1
end

// Helper para converter sub-sequência de bytes para string
// Assumindo to_str converte bytes inteiros, então vamos fatiar
func bytes_to_string(data: bytes, start: int, end_idx: int) -> string
    // slice(bytes, start, end) -> bytes
    // to_str(bytes) -> string (decodifica)
    let sub: bytes = slice(data, start, end_idx)
    return to_str(sub)
end

// Helper para converter string para bytes
func string_to_bytes(s: string) -> bytes
    return to_bytes(s)
end

// Helper para fazer split de string por um delimitador (primeira ocorrência)
// Retorna array de 2 strings: [antes, depois]. Se não achar, [s, ""]
func split_once(s: string, delim: string) -> string[2]
    let res: string[2] = [s, ""]
    let len_s: int = strlen(s)
    let len_d: int = strlen(delim)
    let i: int = 0
    
    while i <= len_s - len_d do
        let sub: string = substring(s, i, i + len_d)
        if sub == delim then
            res[0] = substring(s, 0, i)
            res[1] = substring(s, i + len_d, len_s)
            return res
        end
        i = i + 1
    end
    
    return res
end

// Helper para trim de espaços (simplificado)
func trim(s: string) -> string
    if strlen(s) == 0 then return "" end
    
    // Simplificação: apenas retorna a string por enquanto
    // Noxy não tem suporte fácil a checar isspace char a char ainda
    // Se necessário, implementar checagem de ' ' e '\t'
    return s
end

// ============================================
// Parse de URL
// ============================================

func parse_url(url: string) -> HttpUrl
    let res: HttpUrl = HttpUrl("http", "", 80, "/", "", "", false)
    
    if strlen(url) == 0 then return res end
    
    let current: string = url
    
    // 1. Scheme
    let parts_scheme: string[2] = split_once(current, "://")
    if strlen(parts_scheme[1]) > 0 then
        res.scheme = parts_scheme[0]
        current = parts_scheme[1]
    else
        // Sem scheme explícito, assume http:// se não começar com /
        // Mas a spec diz "HttpUrl default scheme http"
    end
    
    // Define porta padrão baseada no scheme
    if res.scheme == "https" then res.port = 443 else res.port = 80 end
    
    // 2. Fragment (#)
    let parts_frag: string[2] = split_once(current, "#")
    if strlen(parts_frag[1]) > 0 then
        res.fragment = parts_frag[1]
        current = parts_frag[0]
    end
    
    // 3. Query (?)
    let parts_query: string[2] = split_once(current, "?")
    if strlen(parts_query[1]) > 0 then
        res.query = parts_query[1]
        current = parts_query[0]
    end
    
    // 4. Path e Authority
    // A string restante em 'current' tem formato "host:port/path" ou "host/path"
    
    // Separa no primeiro '/'
    let parts_path: string[2] = split_once(current, "/")
    let authority: string = parts_path[0]
    
    if strlen(parts_path[1]) > 0 then
        res.path = "/" + parts_path[1]
    else
        // Se a URL original tinha barra no final ou se não tinha path
        // Se authority terminava com /, o split retornou "" no parts_path[1]
        // Precisamos checar se tinha barra na URL original?
        // Simplificação: se não achou path, é /
        res.path = "/"
        // Correção bug split: se string é "example.com/", split("/") -> ["example.com", ""]
        // Se é "example.com", split("/") -> ["example.com", ""]
        // Precisamos verificar se a url tinha "/"
    end
    
    // 5. Host e Port (Authority)
    let parts_port: string[2] = split_once(authority, ":")
    if strlen(parts_port[1]) > 0 then
        res.host = parts_port[0]
        res.port = to_int(parts_port[1])
    else
        res.host = authority
    end
    
    res.valid = true
    return res
end

// ============================================
// Parse Request/Response
// ============================================

func parse_headers(raw_str: string) -> string[64]
    let headers: string[64]
    // Não temos split_lines fácil, vamos processar linha a linha manualmente ou assumir que já temos vetor?
    // A funcao parse_request vai processar linha a linha a partir dos bytes.
    return headers
end

func parse_request(raw_data: bytes, data_len: int) -> HttpRequest
    let req: HttpRequest = HttpRequest("GET", "/", "", "HTTP/1.1", [], 0, b"")
    
    // 1. Processar Request Line e Headers
    // Vamos iterar procurando CRLF
    
    let cursor: int = 0
    let line_start: int = 0
    let is_body: bool = false
    let line_count: int = 0
    
    let empty_headers: string[64] // Inicializa array vazio
    req.headers = empty_headers
    
    while cursor < data_len do
        let crlf_pos: int = find_crlf(raw_data, cursor, data_len)
        
        if crlf_pos == -1 then
            // Sem mais CRLF, o resto é body ou fim
            if !is_body then
                // Se ainda estávamos nos headers, algo errado ou fim abrupto
                // Assumimos resto como body se tiver algo
                if cursor < data_len then
                   req.body = slice(raw_data, cursor, data_len) 
                end
            end
            break // Sai do loop
        end
        
        // Temos uma linha de cursor até crlf_pos
        
        // Verifica linha vazia (fim dos headers)
        if crlf_pos == cursor then
            is_body = true
            // Pula o CRLF
            cursor = crlf_pos + 2
            // O resto é body
            if cursor < data_len then
                req.body = slice(raw_data, cursor, data_len)
            end
            break // Terminou parse
        end
        
        // Processa linha
        let line_str: string = bytes_to_string(raw_data, cursor, crlf_pos)
        
        if line_count == 0 then
            // Request Line: GET /path HTTP/1.1
            let parts1: string[2] = split_once(line_str, " ")
            req.method = parts1[0]
            
            let remainder: string = parts1[1]
            let parts2: string[2] = split_once(remainder, " ")
            let full_path: string = parts2[0]
            req.version = parts2[1]
            
            // Separa path e query
            let parts_q: string[2] = split_once(full_path, "?")
            req.path = parts_q[0]
            req.query = parts_q[1]
            
        else
            // Header: Name: Value
            // Armazena string inteira por enquanto, conforme struct "Name: Value"
            if req.header_count < 64 then
                req.headers[req.header_count] = line_str
                req.header_count = req.header_count + 1
            end
        end
        
        line_count = line_count + 1
        cursor = crlf_pos + 2 // Avança após \r\n
    end
    
    return req
end

func parse_response(raw_data: bytes, data_len: int) -> HttpResponse
    let resp: HttpResponse = HttpResponse("HTTP/1.1", 200, "OK", [], 0, b"")
    
    let cursor: int = 0
    let is_body: bool = false
    let line_count: int = 0
    
    let empty_headers: string[64]
    resp.headers = empty_headers
    
    while cursor < data_len do
        let crlf_pos: int = find_crlf(raw_data, cursor, data_len)
        
        if crlf_pos == -1 then
            if !is_body & (cursor < data_len) then
                resp.body = slice(raw_data, cursor, data_len)
            end
            break
        end
        
        if crlf_pos == cursor then
            is_body = true
            cursor = crlf_pos + 2
            if cursor < data_len then
                resp.body = slice(raw_data, cursor, data_len)
            end
            break
        end
        
        let line_str: string = bytes_to_string(raw_data, cursor, crlf_pos)
        
        if line_count == 0 then
            // Status Line: HTTP/1.1 200 OK
            let parts1: string[2] = split_once(line_str, " ")
            resp.version = parts1[0]
            
            let remainder: string = parts1[1]
            let parts2: string[2] = split_once(remainder, " ")
            
            // O código pode não ter texto depois, cuidado com split
            resp.status_code = to_int(parts2[0])
            resp.status_text = parts2[1] // Pode estar vazio se não tiver texto? "HTTP/1.1 200"
            
        else
            if resp.header_count < 64 then
                resp.headers[resp.header_count] = line_str
                resp.header_count = resp.header_count + 1
            end
        end
        
        line_count = line_count + 1
        cursor = crlf_pos + 2
    end
    
    return resp
end

// ============================================
// Build Request/Response
// ============================================

func build_request(method: string, path: string, headers: string[64], header_count: int, body: bytes) -> bytes
    let req_str: string = method + " " + path + " HTTP/1.1\r\n"
    
    let i: int = 0
    while i < header_count do
        req_str = req_str + headers[i] + "\r\n"
        i = i + 1
    end
    
    req_str = req_str + "\r\n"
    
    let head_bytes: bytes = to_bytes(req_str)
    
    // Concatena head e body
    return head_bytes + body
end

func build_response(status_code: int, status_text: string, headers: string[64], header_count: int, body: bytes) -> bytes
    let status_line: string = "HTTP/1.1 " + to_str(status_code) + " " + status_text + "\r\n"
    let resp_str: string = status_line
    
    let i: int = 0
    while i < header_count do
        resp_str = resp_str + headers[i] + "\r\n"
        i = i + 1
    end
    
    resp_str = resp_str + "\r\n"
    
    let head_bytes: bytes = to_bytes(resp_str)
    return head_bytes + body
end

// ============================================
// Header Manipulation
// ============================================

func get_header(req: ref HttpRequest, name: string) -> string
    let search: string = name + ":"
    // Simplificado: case sensitive por enquanto no prefixo, 
    // mas ideal seria case-insensitive
    
    let i: int = 0
    while i < req.header_count do
        // Checagem "contains" ou starts with manual?
        // Vamos usar uma abordagem simples: name + ":"
        // Deveria normalizar para lower case
        
        let header_line: string = req.headers[i]
        
        // Verifica se começa com name:
        // Como não temos starts_with ainda ou lower(), vamos fazer um check manual básico
        // ou usar substring
        if strlen(header_line) > strlen(search) then
            let prefix: string = substring(header_line, 0, strlen(search))
            // Se for igual (case sensitive aqui :/) 
            if prefix == search then
                let parts: string[2] = split_once(header_line, ":")
                return trim(parts[1])
            end
        end
        i = i + 1
    end
    
    return ""
end

func set_header(headers: ref string[64], header_count: ref int, name: string, value: string) -> void
    if header_count < 64 then
        headers[header_count] = name + ": " + value
        header_count = header_count + 1
    end
end
