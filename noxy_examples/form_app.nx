use http_server select *
use http_parser select *
use net select *
use io select *

// --- Helper Functions ---

func string_replace_once(s: string, old_val: string, new_val: string) -> string
    let parts: string[2] = split_once(s, old_val)
    // Se parts[1] for vazio e s não termina com old_val (e old_val não está no fim), split_once retorna [s, ""]
    // Mas split_once do http_parser retorna [s, ""] se não achar.
    
    // Check if found:
    // Se parts[0] == s e parts[1] == "", nao achou?
    // Excecao: s="foo", old="bar" -> ["foo", ""]
    // s="foo", old="foo" -> ["", ""]
    
    // Melhor verificar se s contem old_val? Não tem contains.
    // Vamos confiar no split_once comportamento observado no http_parser:
    // "res[0] = substring(s, 0, i); res[1] = substring(s, i + len_d, len_s)"
    // Se ele achou, retornou as partes separadas.
    // Se ele NAO achou, "res[0] = s; res[1] = """
    
    let combined: string = parts[0] + old_val + parts[1]
    if combined == s then
         // Achou (pq reconstruiu igual) -> Errado, logica inversa.
         // Se eu reconstruir com old_val e der igual s, entao o split foi feito corretamente?
         // Se ele nao achou, parts[0]=s, parts[1]="", combined = s + old + "" != s
         
         // Entao se combined != s, significa que NAO achou?
         // Se nao achou: parts[0]=s, parts[1]="". combined = s + old. combined != s.
         // Se achou: parts[0]=prefix, parts[1]=suffix. combined = prefix + old + suffix == s.
         return parts[0] + new_val + parts[1]
    end
    
    return s
end

func read_stored_name() -> string
    if exists("stored_name.txt") then
        let f: File = open("stored_name.txt", "r")
        let res: IOResult = read(f)
        close(f)
        if res.ok then
            if strlen(res.data) > 0 then
                return res.data
            end
        end
    end
    return "Stranger"
end

func save_name(name: string) -> void
    let f: File = open("stored_name.txt", "w")
    write(f, name)
    close(f)
end

func parse_form_data(body: string) -> string
    // Esperado: username=Valor+Teste...
    // Simplificado: Pega valor de username=
    let key: string = "username="
    let parts: string[2] = split_once(body, key)
    if parts[0] == body then
         // Não achou username=
         return "Unknown"
    end
    
    // O valor é parts[1]. Pode ter &outra_coisa=...
    let val_parts: string[2] = split_once(parts[1], "&")
    let raw_val: string = val_parts[0]
    
    // Decode simples de + para espaco
    // Não temos replace_all, vamos fazer um replace once loop ou so assumir 1 palavra
    // Vamos tentar processar manualmente
    
    // Noxy não tem iterador de string facil ou replace all.
    // Vamos apenas retornar raw por enquanto
    return raw_val
end

// --- Handlers ---

func handle_request(req: HttpRequest) -> HttpResponse
    print("Request: " + req.method + " " + req.path)
    
    if req.method == "GET" then
        if req.path == "/" then
            let name: string = read_stored_name()
            
            // Ler template
            let f: File = open("noxy_examples/public/index.html", "r")
            let res: IOResult = read(f)
            close(f)
            
            if !res.ok then
                return response_error(500, "Could not load template")
            end
            
            let html: string = res.data
            
            // Replace {{LAST_USER}}
            // Precisamos garantir que substituimos. 
            // O split_once na logica do string_replace_once deve funcionar se implementado certo
            // Mas vamos fazer hardcoded aqui para garantir
            
            let parts: string[2] = split_once(html, "{{LAST_USER}}")
            // Se achou, parts[0] e parts[1] tem conteudo diff de html e "" (a menos que seja inicio/fim)
            // Verificacao segura: se parts[0] + "{{LAST_USER}}" + parts[1] == html
            
            let check: string = parts[0] + "{{LAST_USER}}" + parts[1]
            if check == html then
                 html = parts[0] + name + parts[1]
            end
            
            return response_html(html)
        end
    end
    
    if req.method == "POST" then
        if req.path == "/" then
            let body_str: string = to_str(req.body)
            let name: string = parse_form_data(body_str)
            
            print("Saving name: " + name)
            save_name(name)
            
            // Redirect back to GET /
            let headers: string[64]
            headers[0] = "Location: /"
            return HttpResponse("HTTP/1.1", 303, "See Other", headers, 1, b"")
        end
    end
    
    return response_error(404, "Not Found")
end

// --- Main Server Setup ---

print("Starting Form App on port 8080...")
let server: HttpServer = new_server("127.0.0.1", 8080)

if start(server) then
    print("Server running. Open http://localhost:8080")
    
    while true do
        let event: RequestEvent = server_poll(server)
        
        if event.type == "REQUEST" then
            let resp: HttpResponse = handle_request(event.request)
            server_send(server, event.client_index, resp)
        end
    end
else
    print("Failed to start server")
end
