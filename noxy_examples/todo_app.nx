use http_server select *
use http_parser select *
use net select *
use io
use sqlite

// ============================================
// Database Setup
// ============================================

global db: Database = sqlite.open("todo.db")

func init_db() -> void
    if !db.open then
        print("Failed to open database 'todo.db'")
        return
    end

    // Create table if not exists
    // completed: 0 = false, 1 = true
    let sql: string = "CREATE TABLE IF NOT EXISTS todos (id INTEGER PRIMARY KEY, title TEXT, completed INTEGER)"
    let res: ExecResult = sqlite.exec(db, sql)
    
    if !res.ok then
        print("DB Init Error: " + res.error)
    else
        print("Database initialized.")
    end
end

// ============================================
// IO / JSON Helpers (Simplified)
// ============================================
// Since Noxy doesn't have a JSON parser yet, we do manual parsing for this MVP.
// Expected formats:
// POST: {"title": "Buy milk"}
// PUT: {"id": 1} (Toggles state)
// DELETE: {"id": 1}

func get_json_string_field(json: string, key: string) -> string
    // Very naive parser: looks for "key": "value"
    // Limitations: doesn't handle escaped quotes, nested objects, spaces variability well.
    let search_key: string = "\"" + key + "\":"
    let parts: string[2] = split_once(json, search_key)
    
    if parts[1] == "" & parts[0] == json then return "" end // Not found
    
    // parts[1] starts with "value"..., skip leading quote if any or spaces
    // Assuming strictly: "key": "value" or "key":"value"
    
    let remainder: string = parts[1]
    
    // Trim leading whitespace/chars until quote
    // Since we don't have trim, let's assume standard format from our frontend
    // Frontend sends: {"title":"..."}
    
    // Find first quote
    let val_parts: string[2] = split_once(remainder, "\"")
    if val_parts[1] == "" then return "" end // No starting quote
    
    // val_parts[1] is value"...
    let final_parts: string[2] = split_once(val_parts[1], "\"")
    return final_parts[0]
end

func get_json_int_field(json: string, key: string) -> int
    // Looks for "key": 123
    let search_key: string = "\"" + key + "\":"
    let parts: string[2] = split_once(json, search_key)
    
    if parts[1] == "" & parts[0] == json then return -1 end
    
    let remainder: string = parts[1]
    // Extract number. Find next , or }
    
    // Hacky: iterate and build string? restricted functionality.
    // Let's rely on split_once again.
    // Try splitting by ,
    let comma_split: string[2] = split_once(remainder, ",")
    let val_str: string = comma_split[0]
    
    // If no comma, maybe it ends with }
    let brace_split: string[2] = split_once(val_str, "}")
    val_str = brace_split[0]
    
    // Trim spaces (manual)?
    // Let's create a helper to parse int properly from " 123 "
    // to_int() usually handles basic strings.
    return to_int(val_str)
end

// ============================================
// Handlers
// ============================================

func handle_get_todos() -> HttpResponse
    let query: string = "SELECT id, title, completed FROM todos"
    let res: QueryResult = sqlite.query(db, query)
    
    if !res.ok then
        return response_error(500, "DB Error: " + res.error)
    end
    
    // Build JSON manually
    let json: string = "["
    let i: int = 0
    while i < res.row_count do
        let row: Row = res.rows[i]
        let id: string = row.values[0]
        let title: string = row.values[1]
        let completed: string = row.values[2]
        
        // Escape title simply?
        
        let item: string = "{\"id\": " + id + ", \"title\": \"" + title + "\", \"completed\": " + completed + "}"
        json = json + item
        
        if i < res.row_count - 1 then
            json = json + ","
        end
        
        i = i + 1
    end
    json = json + "]"
    
    return response_json(json)
end

func handle_add_todo(body: bytes) -> HttpResponse
    let json: string = to_str(body) // Convert bytes to string (utf-8 assumed)
    let title: string = get_json_string_field(json, "title")
    
    if title == "" then
        return response_error(400, "Missing title")
    end
    
    let stmt: Statement = sqlite.prepare(db, "INSERT INTO todos (title, completed) VALUES (?, 0)")
    sqlite.bind_text(stmt, 1, title)
    let res: ExecResult = sqlite.step_exec(stmt)
    sqlite.finalize(stmt)
    
    if !res.ok then
        return response_error(500, "Failed to insert: " + res.error)
    end
    
    return response_json("{\"status\": \"ok\", \"id\": " + to_str(res.last_insert_id) + "}")
end

func handle_toggle_todo(body: bytes) -> HttpResponse
    let json: string = to_str(body)
    let id: int = get_json_int_field(json, "id")
    
    if id == -1 then
        return response_error(400, "Missing id")
    end
    
    // First check current status to toggle
    // Simplified: just set to NOT current. requires query first.
    // Or SQL: UPDATE todos SET completed = NOT completed ... (sqlite supports this? 1-completed works)
    
    let sql: string = "UPDATE todos SET completed = CASE WHEN completed = 0 THEN 1 ELSE 0 END WHERE id = ?"
    let stmt: Statement = sqlite.prepare(db, sql)
    sqlite.bind_int(stmt, 1, id)
    let res: ExecResult = sqlite.step_exec(stmt)
    sqlite.finalize(stmt)
    
    if !res.ok then
        return response_error(500, "DB Error")
    end
    
    return response_json("{\"status\": \"ok\"}")
end

func handle_delete_todo(body: bytes) -> HttpResponse
    let json: string = to_str(body)
    let id: int = get_json_int_field(json, "id")
    
    if id == -1 then
        return response_error(400, "Missing id")
    end
    
    let stmt: Statement = sqlite.prepare(db, "DELETE FROM todos WHERE id = ?")
    sqlite.bind_int(stmt, 1, id)
    let res: ExecResult = sqlite.step_exec(stmt)
    sqlite.finalize(stmt)
    
    if !res.ok then
        return response_error(500, "DB Error")
    end
    
    return response_json("{\"status\": \"ok\"}")
end

// ============================================
// Router
// ============================================

func handle_request(req: HttpRequest) -> HttpResponse
    print(req.method + " " + req.path)
    
    if req.method == "GET" then
        if req.path == "/" then
            return serve_file("noxy_examples/static/index.html")
        end
        if req.path == "/api/todos" then
            return handle_get_todos()
        end
        // Verify if path exists in static (simple check)
        // serving static files mostly
    end
    
    if req.method == "POST" then
        if req.path == "/api/todos" then
            return handle_add_todo(req.body)
        end
    end
    
    if req.method == "PUT" then
        // Avoiding complex path param parsing for now, using body id
        // Using /api/todos/toggle as endpoint
        if req.path == "/api/todos/toggle" then
            return handle_toggle_todo(req.body)
        end
    end
    
    if req.method == "DELETE" then
        if req.path == "/api/todos/delete" then
            return handle_delete_todo(req.body)
        end
    end
    
    return response_error(404, "Not Found")
end

// ============================================
// Main
// ============================================

init_db()

let server: HttpServer = new_server("127.0.0.1", 8080)

if start(server) then
    print("TODO Server running at http://127.0.0.1:8080/")
    
    while true do
        let event: RequestEvent = server_poll(server)
        
        if event.type == "REQUEST" then
            let resp: HttpResponse = handle_request(event.request)
            server_send(server, event.client_index, resp)
        end
    end
else
    print("Failed to start server")
end

sqlite.close(db)
